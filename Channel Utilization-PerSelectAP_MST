#This file formats Channel Utilization- API networks/{network_id}/networkHealth/channelUtilization in an Excel Spreadsheet to see AP data nicely.
#Per network, per requested AP MST timezone.
#https://jamiegprice.substack.com/ @jamiegprice CWNE #510

import requests
from datetime import datetime, timedelta
import pandas as pd
import pytz
import re

BASE_URL = 'https://api.meraki.com/api/v1/'

def get_api_key():
    return input("Enter your Meraki API key: ")

def get_organizations(api_key):
    headers = {'X-Cisco-Meraki-API-Key': api_key}
    try:
        response = requests.get(BASE_URL + 'organizations', headers=headers)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error occurred during API call: {e}")
        return []

def display_organizations(organizations):
    print("Organizations:")
    for idx, org in enumerate(organizations, 1):
        print(f"{idx}. {org['name']} (ID: {org['id']})")
    print()

def select_organization(organizations):
    if len(organizations) == 1:
        print(f"Only one organization found: {organizations[0]['name']} (ID: {organizations[0]['id']})")
        return organizations[0]['id']
    else:
        while True:
            try:
                org_idx = int(input("Enter the number of the organization: ")) - 1
                if 0 <= org_idx < len(organizations):
                    return organizations[org_idx]['id']
                else:
                    print("Invalid choice, please try again.")
            except ValueError:
                print("Invalid input, please enter a number.")

def get_networks(api_key, org_id):
    headers = {'X-Cisco-Meraki-API-Key': api_key}
    try:
        response = requests.get(BASE_URL + f'organizations/{org_id}/networks', headers=headers)
        response.raise_for_status()
        networks = response.json()
        networks.sort(key=lambda x: x['name'])  # Sort networks alphabetically
        return networks
    except requests.exceptions.RequestException as e:
        print(f"Error occurred during API call: {e}")
        return []

def display_networks(networks):
    print("Networks:")
    for idx, network in enumerate(networks, 1):
        print(f"{idx}. {network['name']} (ID: {network['id']})")
    print()

def select_network(networks):
    while True:
        choice = input("Enter the number of the network to select (or 'q' to quit): ")
        if choice.lower() == 'q':
            return None
        try:
            net_idx = int(choice) - 1
            if 0 <= net_idx < len(networks):
                return networks[net_idx]['id']
            else:
                print("Invalid choice, please try again.")
        except ValueError:
            print("Invalid input, please enter a number.")

def get_access_points(api_key, network_id):
    headers = {'X-Cisco-Meraki-API-Key': api_key}
    all_access_points = []
    url = BASE_URL + f'networks/{network_id}/devices'
    
    while url:
        try:
            response = requests.get(url, headers=headers)
            response.raise_for_status()
            access_points = response.json()
            
            if isinstance(access_points, list):
                print(f"Fetched {len(access_points)} access points from {url}")
                all_access_points.extend(access_points)
                
                # No pagination for this endpoint; exit loop
                break
            
            else:
                print(f"Unexpected response format: {access_points}")
                break

        except requests.exceptions.RequestException as e:
            print(f"Error occurred during API call: {e}")
            break
    
    return all_access_points

def get_channel_utilization(api_key, network_id, ap_serial, ap_name):
    headers = {'X-Cisco-Meraki-API-Key': api_key}
    url = BASE_URL + f'networks/{network_id}/networkHealth/channelUtilization'
    all_data = []

    # Calculate the timestamps for the last 2 hours
    t1 = datetime.utcnow()
    t0 = t1 - timedelta(hours=2)
    
    params = {
        'serial': ap_serial,
        't0': t0.isoformat() + 'Z',
        't1': t1.isoformat() + 'Z',
    }

    print(f"Alert: Pulling the last two hours of channel utilization data for AP {ap_name}...")

    try:
        response = requests.get(url, headers=headers, params=params)
        response.raise_for_status()
        data = response.json()
        
        if isinstance(data, list):
            print(f"Fetched {len(data)} data entries for AP {ap_serial} ({ap_name})")
            
            # Add AP name and serial to each entry to ensure correct matching
            for entry in data:
                entry['AP Name'] = ap_name
                entry['AP Serial'] = ap_serial
                all_data.append(entry)
        else:
            print(f"Unexpected response format for AP {ap_serial}: {data}")
        
    except requests.exceptions.RequestException as e:
        print(f"Error occurred during API call for AP {ap_serial}: {e}")
        if e.response is not None:
            print(f"Response content: {e.response.content}")
    
    return all_data

def save_to_excel(data, filename):
    df = pd.DataFrame(data)
    
    # Remove duplicate columns if they exist
    df = df.loc[:, ~df.columns.duplicated()]
    
    if 'AP Name' not in df.columns:
        df['AP Name'] = 'Unknown AP'  # Ensure 'AP Name' column exists
    df = df[['AP Name', 'AP Serial'] + [col for col in df.columns if col not in ['AP Name', 'AP Serial']]]  # Reorder columns to make AP Name first
    df.sort_values(by='AP Name', inplace=True)  # Sort APs alphabetically
    df.to_excel(filename, index=False)
    print(f"Data saved to {filename}")

def convert_utc_to_denver(utc_time_str):
    try:
        # Parse the UTC time string
        utc_time = datetime.strptime(utc_time_str, "%Y-%m-%dT%H:%M:%SZ")
        # Set the timezone to UTC
        utc_time = pytz.utc.localize(utc_time)
        # Convert to Mountain Time (Denver), handling DST
        denver_time = utc_time.astimezone(pytz.timezone('America/Denver'))
        # Return the time in the desired format
        return denver_time.strftime("%Y-%m-%dT%H:%M:%S")
    except ValueError:
        # Return the original string if it's not in the expected format
        return utc_time_str

def replace_utc_in_string(data_str):
    # Regular expression pattern for UTC timestamps
    utc_pattern = re.compile(r'\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z')
    # Function to convert UTC timestamp found in the string
    def convert(match):
        return convert_utc_to_denver(match.group(0))
    
    # Replace all UTC timestamps in the string
    return utc_pattern.sub(convert, data_str)

def process_file(input_filename):
    output_filename = input_filename.replace('.xlsx', '_converted_to_Denver.xlsx')
    
    try:
        # Read the Excel file
        df = pd.read_excel(input_filename)
        
        # Replace UTC timestamps in all string columns
        for column in df.columns:
            if df[column].dtype == 'object':
                df[column] = df[column].apply(lambda x: replace_utc_in_string(x) if isinstance(x, str) else x)
        
        # Save the updated DataFrame to a new Excel file
        df.to_excel(output_filename, index=False)
        print(f"Data has been converted and saved to {output_filename}")

        return output_filename
    
    except Exception as e:
        print(f"An error occurred: {e}")

def cleanup_file(input_filename):
    # Generate a timestamp for the output file name
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    output_filename = f"ChanUtilSelectAPs_{timestamp}.xlsx"

    try:
        # Read the Excel file
        df = pd.read_excel(input_filename)

        # Remove Column A (assuming it's the first column in zero-based index)
        if df.columns.size > 0:
            df.drop(df.columns[0], axis=1, inplace=True)

        # Save the cleaned DataFrame to a new Excel file
        df.to_excel(output_filename, index=False)
        print(f"Cleaned data has been saved to {output_filename}")

    except Exception as e:
        print(f"An error occurred during cleanup: {e}")

def main():
    start_time = datetime.now()

    api_key = get_api_key()
    organizations = get_organizations(api_key)
    if not organizations:
        return
    display_organizations(organizations)

    selected_org_id = select_organization(organizations)

    networks = get_networks(api_key, selected_org_id)
    if not networks:
        return
    display_networks(networks)

    selected_network_id = select_network(networks)
    if not selected_network_id:
        print("No network selected, exiting.")
        return

    # Fetch AP details for the selected network
    access_points = get_access_points(api_key, selected_network_id)
    if not access_points:
        print("No access points found, exiting.")
        return
    
    # Sort APs alphabetically
    access_points.sort(key=lambda x: x['name'])
    
    # Display APs in alphabetical order
    print("Access Points:")
    for idx, ap in enumerate(access_points, 1):
        print(f"{idx}. {ap['name']} (Serial: {ap['serial']})")
    print()

    # Ask user to select APs
    selected_ap_indices = input("Enter the indices of the APs to process, separated by commas: ")
    selected_ap_indices = [int(x.strip()) - 1 for x in selected_ap_indices.split(',')]

    all_data = []
    for idx in selected_ap_indices:
        ap = access_points[idx]
        ap_serial = ap['serial']
        ap_name = ap['name']
        data = get_channel_utilization(api_key, selected_network_id, ap_serial, ap_name)
        all_data.extend(data)

    # Save data to Excel
    filename = 'UtilTemp.xlsx'
    save_to_excel(all_data, filename)
    
    # Automatically process the file
    temp_file = process_file(filename)
    
    if temp_file:
        # Cleanup the temp file
        cleanup_file(temp_file)

    end_time = datetime.now()
    duration = end_time - start_time
    print(f"Job Completed. Time taken: {duration}")

if __name__ == "__main__":
    main()
